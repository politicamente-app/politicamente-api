# PROJETO: politicamente-api/

A estrutura de pastas final do seu projeto, organizada de forma hierárquica e alfabética.

politicamente-api/
├── .env
├── README.md
├── app/
│   ├── api/
│   │   ├── api.py
│   │   └── endpoints/
│   │       └── auth.py
│   ├── core/
│   │   ├── config.py
│   │   └── security.py
│   ├── db/
│   │   ├── base.py
│   │   ├── base_class.py
│   │   └── session.py
│   ├── main.py
│   ├── models/
│   │   └── user.py
│   ├── repository/
│   │   └── user.py
│   └── schemas/
│       └── user.py
└── tests/
    ├── integration/
    │   └── test_auth.py
    └── unit/
        └── test_security.py


A seguir, o conteúdo completo de cada arquivo, com as novas implementações.

---
## Arquivo: .env

# Cole aqui o URL de conexão do seu banco de dados PostgreSQL do Supabase (usando o "Session Pooler")
DATABASE_URL="cole_sua_string_de_conexao_do_supabase_aqui"

# --- Chaves de Segurança para JWT ---
# IMPORTANTE: Gere uma chave secreta forte e única para o seu projeto.
# Você pode gerar uma no terminal com o comando: openssl rand -hex 32
SECRET_KEY="sua_chave_secreta_super_forte_de_32_bytes_aqui"
ALGORITHM="HS256"
ACCESS_TOKEN_EXPIRE_MINUTES=60

---
## Arquivo: README.md

# PoliticaMente API

Este é o repositório do backend para a plataforma **PoliticaMente**. Construído com FastAPI e Python, este serviço é responsável por toda a lógica de negócio, segurança e gestão de dados da aplicação.

## Filosofia

O PoliticaMente nasceu como um projeto **open source** com foco total em **segurança, privacidade e transparência**. Acreditamos que, ao lidar com dados sensíveis, a melhor abordagem é permitir que a comunidade audite e contribua para a robustez da plataforma.

## Começando

Siga estas instruções para ter uma cópia do projeto funcionando na sua máquina local para desenvolvimento e testes (ambiente WSL/Linux recomendado).

### Pré-requisitos

* Python 3.9+ (instalado no WSL)
* `pip` e `venv` (instalados no WSL com `sudo apt install python3-pip python3-venv`)

### Instalação

1.  **Clone o repositório:**
    ```sh
    git clone [https://github.com/politicamente-app/politicamente-api.git](https://github.com/politicamente-app/politicamente-api.git)
    cd politicamente-api
    ```

2.  **Crie e ative um ambiente virtual:**
    ```sh
    python -m venv venv
    source venv/bin/activate
    ```

3.  **Instale as dependências:**
    ```sh
    # Dependências da Aplicação
    pip install fastapi "uvicorn[standard]" "pydantic[email]" "passlib[bcrypt]" sqlalchemy psycopg2-binary python-dotenv pydantic-settings "python-jose[cryptography]"

    # Dependências de Teste
    pip install pytest httpx
    ```
4.  **Crie o arquivo `.env`:**
    * Crie um arquivo chamado `.env` na pasta raiz do projeto.
    * Dentro dele, adicione sua string de conexão do Supabase e as configurações de segurança:
        ```
        DATABASE_URL="postgresql://postgres.[SEU_ID]:[SUA_SENHA]@[aws-0-sa-east-1.pooler.supabase.com:5432/postgres](https://aws-0-sa-east-1.pooler.supabase.com:5432/postgres)"

        # Execute `openssl rand -hex 32` no terminal para gerar uma chave segura
        SECRET_KEY="sua_chave_secreta_aqui"
        ALGORITHM="HS256"
        ACCESS_TOKEN_EXPIRE_MINUTES=60
        ```

### Executar a Aplicação

1.  Com seu ambiente virtual ativado, execute o servidor de desenvolvimento Uvicorn a partir da pasta raiz (`politicamente-api/`):
    ```sh
    uvicorn app.main:app --reload
    ```
    A flag `--reload` faz com que o servidor reinicie automaticamente após cada alteração no código.

2.  Abra seu navegador e acesse [http://127.0.0.1:8000](http://127.0.0.1:8000). Você deverá ver a mensagem: `{"message":"Bem-vindo à API do PoliticaMente"}`.

### Executar os Testes

1.  Com seu ambiente virtual ativado, execute o Pytest a partir da pasta raiz (`politicamente-api/`):
    ```sh
    pytest
    ```
    O Pytest irá descobrir e executar automaticamente todos os testes dentro da pasta `tests/`.

---
## Arquivo: app/api/api.py

from fastapi import APIRouter
from app.api.endpoints import auth

api_router = APIRouter()
api_router.include_router(auth.router, prefix="/auth", tags=["Authentication"])

---
## Arquivo: app/api/endpoints/auth.py

from fastapi import APIRouter, status, Depends, HTTPException
from sqlalchemy.orm import Session
from fastapi.security import OAuth2PasswordRequestForm

from app.schemas.user import UserCreate, UserResponse, Token
from app.repository import user as user_repository
from app.db.session import get_db
from app.core.security import verify_password, create_access_token, get_current_user
from app.models.user import User

router = APIRouter()

@router.post(
    "/register",
    response_model=UserResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Registrar novo usuário"
)
def register_new_user(user_data: UserCreate, db: Session = Depends(get_db)):
    """
    Endpoint para registrar um novo usuário no sistema.
    """
    db_user = user_repository.get_by_email(db, email=user_data.email)
    if db_user:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email already registered",
        )

    new_user = user_repository.create(db=db, user=user_data)

    return new_user

@router.post(
    "/login",
    response_model=Token,
    summary="Login do usuário"
)
def login_for_access_token(db: Session = Depends(get_db), form_data: OAuth2PasswordRequestForm = Depends()):
    """
    Autentica um usuário e retorna um token de acesso JWT.

    O FastAPI usa o OAuth2PasswordRequestForm para esperar um corpo de formulário com 'username' e 'password'.
    O 'username' neste caso será o nosso e-mail.
    """
    user = user_repository.get_by_email(db, email=form_data.username)

    if not user or not verify_password(form_data.password, user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect email or password",
            headers={"WWW-Authenticate": "Bearer"},
        )

    access_token = create_access_token(data={"sub": user.email})

    return {"access_token": access_token, "token_type": "bearer"}

@router.get(
    "/users/me",
    response_model=UserResponse,
    summary="Obter usuário atual"
)
def read_users_me(current_user: User = Depends(get_current_user)):
    """
    Endpoint protegido que retorna os dados do usuário logado.
    """
    return current_user

---
## Arquivo: app/core/config.py

from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    DATABASE_URL: str
    SECRET_KEY: str
    ALGORITHM: str
    ACCESS_TOKEN_EXPIRE_MINUTES: int

    class Config:
        env_file = ".env"

settings = Settings()

---
## Arquivo: app/core/security.py

from datetime import datetime, timedelta, timezone
from passlib.context import CryptContext
from jose import JWTError, jwt
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from sqlalchemy.orm import Session

from app.core.config import settings
from app.db.session import get_db
from app.repository import user as user_repository
from app.models.user import User

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# Define o esquema de segurança: o token será esperado no header 'Authorization'
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/auth/login")


def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verifica se a senha fornecida corresponde ao hash guardado."""
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    """Gera um hash seguro da senha."""
    return pwd_context.hash(password)

def create_access_token(data: dict):
    """Cria um novo token de acesso JWT."""
    to_encode = data.copy()
    expire = datetime.now(timezone.utc) + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    return encoded_jwt

def get_current_user(db: Session = Depends(get_db), token: str = Depends(oauth2_scheme)) -> User:
    """
    Dependência para obter o usuário atual a partir do token JWT.
    """
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        email: str = payload.get("sub")
        if email is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception

    user = user_repository.get_by_email(db, email=email)
    if user is None:
        raise credentials_exception
    return user

---
## Arquivo: app/db/base.py

# Este arquivo é usado para inicializar o banco de dados e garantir
# que o SQLAlchemy conheça todos os nossos modelos e a engine.
from app.db.base_class import Base
from app.models.user import User
from app.db.session import engine

---
## Arquivo: app/db/base_class.py

from sqlalchemy.orm import declarative_base

# Base declarativa que nossos modelos de tabela irão herdar.
Base = declarative_base()

---
## Arquivo: app/db/session.py

from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from app.core.config import settings

engine = create_engine(settings.DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

---
## Arquivo: app/main.py

from fastapi import FastAPI
from app.api.api import api_router
from app.db import base

# Cria todas as tabelas no banco de dados (se não existirem)
base.Base.metadata.create_all(bind=base.engine)

app = FastAPI(
    title="PoliticaMente API",
    description="Backend para a plataforma PoliticaMente.",
    version="1.0.0"
)

app.include_router(api_router)

@app.get("/", tags=["Root"])
def read_root():
    """Endpoint inicial para verificar se a API está no ar."""
    return {"message": "Bem-vindo à API do PoliticaMente"}

---
## Arquivo: app/models/user.py

import uuid
from sqlalchemy import Column, String, DateTime
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.sql import func
from app.db.base_class import Base

class User(Base):
    """Modelo da tabela 'users' no banco de dados."""
    __tablename__ = "users"

    user_id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    full_name = Column(String, nullable=False)
    email = Column(String, unique=True, index=True, nullable=False)
    hashed_password = Column(String, nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())

---
## Arquivo: app/repository/user.py

from sqlalchemy.orm import Session
from app.models.user import User
from app.schemas.user import UserCreate
from app.core.security import get_password_hash

def get_by_email(db: Session, email: str) -> User | None:
    """Busca um usuário pelo seu e-mail."""
    return db.query(User).filter(User.email == email).first()

def create(db: Session, user: UserCreate) -> User:
    """Cria um novo usuário no banco de dados."""
    hashed_password = get_password_hash(user.password)
    db_user = User(
        full_name=user.full_name,
        email=user.email,
        hashed_password=hashed_password
    )
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    return db_user

---
## Arquivo: app/schemas/user.py

import uuid
from pydantic import BaseModel, EmailStr, Field

class UserCreate(BaseModel):
    """Schema para a criação de um usuário."""
    full_name: str = Field(..., min_length=3, example="José da Silva")
    email: EmailStr = Field(..., example="jose.silva@email.com")
    password: str = Field(..., min_length=8, example="senhaSegura123")

class UserResponse(BaseModel):
    """Schema para a resposta da API ao criar/obter um usuário."""
    user_id: uuid.UUID
    full_name: str
    email: EmailStr

    class Config:
        from_attributes = True

class Token(BaseModel):
    """Schema para a resposta do token de acesso."""
    access_token: str
    token_type: str

---
## Arquivo: tests/integration/test_auth.py

from fastapi.testclient import TestClient
from app.main import app
from app.repository import user as user_repository
from app.db.session import get_db
from sqlalchemy.orm import Session

# Nota: Para um projeto real, usaríamos um banco de dados de teste separado.
# Por enquanto, este teste irá interagir com o seu banco de dados de desenvolvimento.

client = TestClient(app)

def test_full_auth_flow():
    # 1. Registro
    email = "test.user.flow@example.com"
    password = "password123"
    response = client.post(
        "/auth/register",
        json={"full_name": "Test Flow User", "email": email, "password": password},
    )
    # Ignora se o usuário já existe de um teste anterior
    assert response.status_code in [201, 400]

    # 2. Login
    response = client.post(
        "/auth/login",
        data={"username": email, "password": password},
    )
    assert response.status_code == 200
    token_data = response.json()
    assert "access_token" in token_data
    access_token = token_data["access_token"]

    # 3. Acesso à Rota Protegida
    response = client.get(
        "/auth/users/me",
        headers={"Authorization": f"Bearer {access_token}"},
    )
    assert response.status_code == 200
    user_data = response.json()
    assert user_data["email"] == email

def test_get_current_user_no_token():
    response = client.get("/auth/users/me")
    assert response.status_code == 401 # Unauthorized

def test_get_current_user_invalid_token():
    response = client.get(
        "/auth/users/me",
        headers={"Authorization": "Bearer tokeninvalido"},
    )
    assert response.status_code == 401 # Unauthorized

---
## Arquivo: tests/unit/test_security.py

from app.core.security import get_password_hash, verify_password

def test_password_hashing():
    """
    Testa se o hashing e a verificação da senha funcionam corretamente.
    """
    password = "senhaSegura123"

    hashed_password = get_password_hash(password)

    assert password != hashed_password
    assert verify_password(password, hashed_password) == True
    assert verify_password("senhaIncorreta", hashed_password) == False
